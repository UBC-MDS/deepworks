# From Ilya's Lecture 5
# Example 4a: AI Code Critic Issues
name: AI Critic (Issues)

on:
  issues:
   types: [opened, reopened]
  workflow_dispatch:

permissions:
  contents: read
  issues: write

jobs:
  analyze_issue:
    runs-on: ubuntu-latest
    steps:
      - name: Ask AI critic (Gemini)
        id: ai-response
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          ISSUE_USER: ${{ github.event.issue.user.login }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
        run: |
          # 1. Define the System Prompt
          SYSTEM_PROMPT="You are a helpful issue triage assistant for this repository.
          Your task is to analyze newly opened issues for completeness and clarity.

          If the issue is clear, detailed, and includes reproducibility steps, thank the contributor and confirm the issue is well-documented.

          If the issue is vague, missing steps to reproduce, or poorly formatted, politely point out what's missing. Offer specific suggestions on how to improve it, such as adding environment details, expected vs. actual behavior, or error messages.

          Be encouraging and constructiveâ€”remember that contributors may be new to open source.

          Identify any missing information that would help resolve the issue faster.
          Always respond with ready-to-use markdown content."
          
          # 2. Construct the JSON payload securely using jq
          # We construct the user prompt inside jq to handle newlines/quotes in the issue body safely
          jq -n \
            --arg system_prompt "$SYSTEM_PROMPT" \
            --arg user "$ISSUE_USER" \
            --arg title "$ISSUE_TITLE" \
            --arg body "$ISSUE_BODY" \
            '{
              contents: [{ parts: [{ text: ("New issue was opened by " + $user + "\nTitle: " + $title + "\nBody:\n---\n" + $body + "\n---") }] }],
              system_instruction: { parts: [{ text: $system_prompt }] }
            }' > payload.json

          # 3. Call Gemini API (gemini-2.5-flash)
          RESPONSE=$(curl -s -X POST \
            -H "Content-Type: application/json" \
            -H "x-goog-api-key: $GEMINI_API_KEY" \
            -d @payload.json \
            "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent")

          # 4. Parse the output text using jq
          REVIEW=$(echo "$RESPONSE" | jq -r '.candidates[0].content.parts[0].text // "Error: Failed to get response from Gemini. Check logs for details."')

          # 5. Set the output for the next step (using heredoc for multiline safety)
          EOF=$(dd if=/dev/urandom bs=15 count=1 status=none | base64)
          echo "response<<$EOF" >> "$GITHUB_OUTPUT"
          echo "$REVIEW" >> "$GITHUB_OUTPUT"
          echo "$EOF" >> "$GITHUB_OUTPUT"

      - name: Comment results on the issue
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          issue-number: ${{ github.event.issue.number }}
          body: ${{ steps.ai-response.outputs.response }}
